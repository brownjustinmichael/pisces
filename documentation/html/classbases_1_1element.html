<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Spectral Element Code: bases::element Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Spectral Element Code
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebases.html">bases</a></li><li class="navelem"><a class="el" href="classbases_1_1element.html">element</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classbases_1_1element-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">bases::element Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>This is the basic class of the code.  
 <a href="classbases_1_1element.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="element_8hpp_source.html">element.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for bases::element:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbases_1_1element.png" usemap="#bases::element_map" alt=""/>
  <map id="bases::element_map" name="bases::element_map">
<area href="classone__d_1_1element.html" title="The 1D base element class." alt="one_d::element" shape="rect" coords="145,56,426,80"/>
<area href="classone__d_1_1chebyshev_1_1element.html" title="A Chebyshev implementation of the 1D element class." alt="one_d::chebyshev::element" shape="rect" coords="145,112,426,136"/>
<area href="classone__d_1_1chebyshev_1_1advection__diffusion__element.html" title="A simple implementation of the element class with diffusion." alt="one_d::chebyshev::advection_diffusion_element" shape="rect" coords="0,168,281,192"/>
<area href="classone__d_1_1chebyshev_1_1cuda__element.html" alt="one_d::chebyshev::cuda_element" shape="rect" coords="291,168,572,192"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad6c297b8fbb3ea61a1a7048f0fbf7d89"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; int &gt;<br class="typebreak"/>
::<a class="el" href="classbases_1_1element.html#ad6c297b8fbb3ea61a1a7048f0fbf7d89">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbases_1_1element.html#ad6c297b8fbb3ea61a1a7048f0fbf7d89">iterator</a></td></tr>
<tr class="memdesc:ad6c297b8fbb3ea61a1a7048f0fbf7d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator for the element class.  <a href="#ad6c297b8fbb3ea61a1a7048f0fbf7d89">More...</a><br/></td></tr>
<tr class="separator:ad6c297b8fbb3ea61a1a7048f0fbf7d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a06505a1d8050683b6a9a07b4b92f38f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbases_1_1element.html#a06505a1d8050683b6a9a07b4b92f38f5">element</a> (int i_name, int n_boundaries, <a class="el" href="namespaceio.html#a1c55c654666eeece6a9724f453fdbd87">io::parameter_map</a> &amp;i_inputParams, <a class="el" href="classbases_1_1messenger.html">messenger</a> *i_messenger_ptr, int i_flags)</td></tr>
<tr class="separator:a06505a1d8050683b6a9a07b4b92f38f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae6c42893603fc086c5c207e236f9d8"><td class="memItemLeft" align="right" valign="top">virtual double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbases_1_1element.html#a4ae6c42893603fc086c5c207e236f9d8">operator[]</a> (int <a class="el" href="classbases_1_1element.html#a52af85c34174ec732a3feb6a7e63fbc6">name</a>)=0</td></tr>
<tr class="memdesc:a4ae6c42893603fc086c5c207e236f9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the double reference to the named scalar.  <a href="#a4ae6c42893603fc086c5c207e236f9d8">More...</a><br/></td></tr>
<tr class="separator:a4ae6c42893603fc086c5c207e236f9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8a0151fcc9259e3313558a928fdf62"><td class="memItemLeft" align="right" valign="top">virtual double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbases_1_1element.html#aec8a0151fcc9259e3313558a928fdf62">operator()</a> (int <a class="el" href="classbases_1_1element.html#a52af85c34174ec732a3feb6a7e63fbc6">name</a>, int <a class="el" href="plan_8hpp.html#a6784e1c334dfceb8f017667c0b0f6a3e">index</a>=0)</td></tr>
<tr class="memdesc:aec8a0151fcc9259e3313558a928fdf62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the double reference to the given index of the named scalar.  <a href="#aec8a0151fcc9259e3313558a928fdf62">More...</a><br/></td></tr>
<tr class="separator:aec8a0151fcc9259e3313558a928fdf62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa323f71efe1d063f3a75fb0ae52dd4e4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbases_1_1element.html#ad6c297b8fbb3ea61a1a7048f0fbf7d89">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbases_1_1element.html#aa323f71efe1d063f3a75fb0ae52dd4e4">begin</a> ()</td></tr>
<tr class="memdesc:aa323f71efe1d063f3a75fb0ae52dd4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the iterator for the class at the first scalar index.  <a href="#aa323f71efe1d063f3a75fb0ae52dd4e4">More...</a><br/></td></tr>
<tr class="separator:aa323f71efe1d063f3a75fb0ae52dd4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ecd5c3a4ca85b1a818c9ff0d0d0213"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbases_1_1element.html#ad6c297b8fbb3ea61a1a7048f0fbf7d89">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbases_1_1element.html#a56ecd5c3a4ca85b1a818c9ff0d0d0213">end</a> ()</td></tr>
<tr class="memdesc:a56ecd5c3a4ca85b1a818c9ff0d0d0213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the iterator for the class at the last scalar index.  <a href="#a56ecd5c3a4ca85b1a818c9ff0d0d0213">More...</a><br/></td></tr>
<tr class="separator:a56ecd5c3a4ca85b1a818c9ff0d0d0213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db7290cae3a85a32e28a6f73457c08c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbases_1_1element.html#a4db7290cae3a85a32e28a6f73457c08c">set_grid</a> (std::shared_ptr&lt; <a class="el" href="classbases_1_1collocation__grid.html">collocation_grid</a> &gt; i_grid)</td></tr>
<tr class="memdesc:a4db7290cae3a85a32e28a6f73457c08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the collocation grid.  <a href="#a4db7290cae3a85a32e28a6f73457c08c">More...</a><br/></td></tr>
<tr class="separator:a4db7290cae3a85a32e28a6f73457c08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798c23f47fb27d78569619cff8a03cf8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbases_1_1element.html#a798c23f47fb27d78569619cff8a03cf8">add_solver</a> (std::shared_ptr&lt; <a class="el" href="classbases_1_1solver.html">solver</a> &gt; i_solver)</td></tr>
<tr class="memdesc:a798c23f47fb27d78569619cff8a03cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the matrix solver.  <a href="#a798c23f47fb27d78569619cff8a03cf8">More...</a><br/></td></tr>
<tr class="separator:a798c23f47fb27d78569619cff8a03cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e46cf2492d82e9574ebcdbd39be3391"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbases_1_1element.html#a9e46cf2492d82e9574ebcdbd39be3391">add_transform</a> (std::shared_ptr&lt; <a class="el" href="classbases_1_1plan.html">plan</a> &gt; i_plan)</td></tr>
<tr class="memdesc:a9e46cf2492d82e9574ebcdbd39be3391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the transform operation.  <a href="#a9e46cf2492d82e9574ebcdbd39be3391">More...</a><br/></td></tr>
<tr class="separator:a9e46cf2492d82e9574ebcdbd39be3391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ee0ec9bda610aead7a6c8a02b84e19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbases_1_1element.html#aa3ee0ec9bda610aead7a6c8a02b84e19">add_pre_plan</a> (std::shared_ptr&lt; <a class="el" href="classbases_1_1plan.html">plan</a> &gt; i_plan)</td></tr>
<tr class="memdesc:aa3ee0ec9bda610aead7a6c8a02b84e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a plan to be executed in order.  <a href="#aa3ee0ec9bda610aead7a6c8a02b84e19">More...</a><br/></td></tr>
<tr class="separator:aa3ee0ec9bda610aead7a6c8a02b84e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0b4f2a8cf1aa6f6831ba99fe9d32df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbases_1_1element.html#aac0b4f2a8cf1aa6f6831ba99fe9d32df">add_post_plan</a> (std::shared_ptr&lt; <a class="el" href="classbases_1_1plan.html">plan</a> &gt; i_plan)</td></tr>
<tr class="memdesc:aac0b4f2a8cf1aa6f6831ba99fe9d32df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a plan to be executed in order.  <a href="#aac0b4f2a8cf1aa6f6831ba99fe9d32df">More...</a><br/></td></tr>
<tr class="separator:aac0b4f2a8cf1aa6f6831ba99fe9d32df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ebcca153d00d0279df6c395ad91e83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbases_1_1element.html#ad1ebcca153d00d0279df6c395ad91e83">add_implicit_plan</a> (std::shared_ptr&lt; <a class="el" href="classbases_1_1plan.html">plan</a> &gt; i_plan)</td></tr>
<tr class="memdesc:ad1ebcca153d00d0279df6c395ad91e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an implicit plan to be executed in order once at the start.  <a href="#ad1ebcca153d00d0279df6c395ad91e83">More...</a><br/></td></tr>
<tr class="separator:ad1ebcca153d00d0279df6c395ad91e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0350a45f7aff09ba8ebbfb2a789027"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbases_1_1element.html#a8c0350a45f7aff09ba8ebbfb2a789027">initialize</a> (int <a class="el" href="classbases_1_1element.html#a52af85c34174ec732a3feb6a7e63fbc6">name</a>, double *initial_conditions=NULL)=0</td></tr>
<tr class="memdesc:a8c0350a45f7aff09ba8ebbfb2a789027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the scalar name.  <a href="#a8c0350a45f7aff09ba8ebbfb2a789027">More...</a><br/></td></tr>
<tr class="separator:a8c0350a45f7aff09ba8ebbfb2a789027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a829e5dc54ab249d8b567f608e7f69"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbases_1_1element.html#ac2a829e5dc54ab249d8b567f608e7f69">explicit_reset</a> ()</td></tr>
<tr class="memdesc:ac2a829e5dc54ab249d8b567f608e7f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset every scalar index &lt; 0 and converts to spectral space.  <a href="#ac2a829e5dc54ab249d8b567f608e7f69">More...</a><br/></td></tr>
<tr class="separator:ac2a829e5dc54ab249d8b567f608e7f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0311b32b397accaba0b9066c6c402274"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbases_1_1element.html#a0311b32b397accaba0b9066c6c402274">implicit_reset</a> ()</td></tr>
<tr class="memdesc:a0311b32b397accaba0b9066c6c402274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset any matrices if necessary.  <a href="#a0311b32b397accaba0b9066c6c402274">More...</a><br/></td></tr>
<tr class="separator:a0311b32b397accaba0b9066c6c402274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdb8f7c290f78cc9e9abb019e96eeaf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbases_1_1element.html#aebdb8f7c290f78cc9e9abb019e96eeaf">transform_inverse</a> ()</td></tr>
<tr class="memdesc:aebdb8f7c290f78cc9e9abb019e96eeaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform from spectral space to physical space.  <a href="#aebdb8f7c290f78cc9e9abb019e96eeaf">More...</a><br/></td></tr>
<tr class="separator:aebdb8f7c290f78cc9e9abb019e96eeaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5b77ded6283aec184192d313ee17e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd5b77ded6283aec184192d313ee17e8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>solve</b> ()</td></tr>
<tr class="separator:acd5b77ded6283aec184192d313ee17e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a344e596bf8cee3fdeda611b98bb1c"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbases_1_1element.html#aa8a344e596bf8cee3fdeda611b98bb1c">calculate_timestep</a> ()=0</td></tr>
<tr class="memdesc:aa8a344e596bf8cee3fdeda611b98bb1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the new timestep duration.  <a href="#aa8a344e596bf8cee3fdeda611b98bb1c">More...</a><br/></td></tr>
<tr class="separator:aa8a344e596bf8cee3fdeda611b98bb1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a15277a82abbc28ba75f67817e170a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbases_1_1element.html#a86a15277a82abbc28ba75f67817e170a">execute_boundaries</a> ()=0</td></tr>
<tr class="memdesc:a86a15277a82abbc28ba75f67817e170a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the boundary conditions.  <a href="#a86a15277a82abbc28ba75f67817e170a">More...</a><br/></td></tr>
<tr class="separator:a86a15277a82abbc28ba75f67817e170a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8ef296f0853fc3e1941b696eee7dc9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbases_1_1element.html#a4a8ef296f0853fc3e1941b696eee7dc9">run</a> ()</td></tr>
<tr class="memdesc:a4a8ef296f0853fc3e1941b696eee7dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main function call of the class.  <a href="#a4a8ef296f0853fc3e1941b696eee7dc9">More...</a><br/></td></tr>
<tr class="separator:a4a8ef296f0853fc3e1941b696eee7dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8924e3a51b3c02433c082ebbb94c47d0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbases_1_1element.html#a8924e3a51b3c02433c082ebbb94c47d0">failsafe</a> ()</td></tr>
<tr class="memdesc:a8924e3a51b3c02433c082ebbb94c47d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output all information to a dump file in the current directory.  <a href="#a8924e3a51b3c02433c082ebbb94c47d0">More...</a><br/></td></tr>
<tr class="separator:a8924e3a51b3c02433c082ebbb94c47d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a52af85c34174ec732a3feb6a7e63fbc6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52af85c34174ec732a3feb6a7e63fbc6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbases_1_1element.html#a52af85c34174ec732a3feb6a7e63fbc6">name</a></td></tr>
<tr class="memdesc:a52af85c34174ec732a3feb6a7e63fbc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer representation of the element, to be used in file output. <br/></td></tr>
<tr class="separator:a52af85c34174ec732a3feb6a7e63fbc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac9bb89cc00150c2546e9880e0f677a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adac9bb89cc00150c2546e9880e0f677a"></a>
<a class="el" href="namespaceio.html#a1c55c654666eeece6a9724f453fdbd87">io::parameter_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbases_1_1element.html#adac9bb89cc00150c2546e9880e0f677a">inputParams</a></td></tr>
<tr class="memdesc:adac9bb89cc00150c2546e9880e0f677a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The map that contains the input parameters. <br/></td></tr>
<tr class="separator:adac9bb89cc00150c2546e9880e0f677a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca8319905d8702294384d940a5cf0f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ca8319905d8702294384d940a5cf0f7"></a>
<a class="el" href="classbases_1_1messenger.html">messenger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbases_1_1element.html#a0ca8319905d8702294384d940a5cf0f7">messenger_ptr</a></td></tr>
<tr class="memdesc:a0ca8319905d8702294384d940a5cf0f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the messenger object. <br/></td></tr>
<tr class="separator:a0ca8319905d8702294384d940a5cf0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96e3c9a7a8c0aa53e6f98e62ecf23af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae96e3c9a7a8c0aa53e6f98e62ecf23af"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbases_1_1element.html#ae96e3c9a7a8c0aa53e6f98e62ecf23af">flags</a></td></tr>
<tr class="memdesc:ae96e3c9a7a8c0aa53e6f98e62ecf23af"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer set of execution flags. <br/></td></tr>
<tr class="separator:ae96e3c9a7a8c0aa53e6f98e62ecf23af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47315779623a1472300076f4df1c713b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47315779623a1472300076f4df1c713b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbases_1_1element.html#a47315779623a1472300076f4df1c713b">duration</a></td></tr>
<tr class="memdesc:a47315779623a1472300076f4df1c713b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The double total simulated time. <br/></td></tr>
<tr class="separator:a47315779623a1472300076f4df1c713b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0bd283b49358bd1f5a0b6ec0e1daae0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0bd283b49358bd1f5a0b6ec0e1daae0"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbases_1_1element.html#ac0bd283b49358bd1f5a0b6ec0e1daae0">timestep</a></td></tr>
<tr class="memdesc:ac0bd283b49358bd1f5a0b6ec0e1daae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The double timestep length. <br/></td></tr>
<tr class="separator:ac0bd283b49358bd1f5a0b6ec0e1daae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c487033b765147186f5904cbfe39a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8c487033b765147186f5904cbfe39a6"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbases_1_1element.html#aa8c487033b765147186f5904cbfe39a6">names</a></td></tr>
<tr class="memdesc:aa8c487033b765147186f5904cbfe39a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of integer name indices of the contained scalars. <br/></td></tr>
<tr class="separator:aa8c487033b765147186f5904cbfe39a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be44a6a3cef50bf30850759c9c1f433"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0be44a6a3cef50bf30850759c9c1f433"></a>
std::shared_ptr&lt; <a class="el" href="classbases_1_1collocation__grid.html">collocation_grid</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbases_1_1element.html#a0be44a6a3cef50bf30850759c9c1f433">grid</a></td></tr>
<tr class="memdesc:a0be44a6a3cef50bf30850759c9c1f433"><td class="mdescLeft">&#160;</td><td class="mdescRight">A shared pointer to the collocation grid. <br/></td></tr>
<tr class="separator:a0be44a6a3cef50bf30850759c9c1f433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe96a343a5fea6c7894a5a78bf460155"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe96a343a5fea6c7894a5a78bf460155"></a>
std::shared_ptr&lt; <a class="el" href="classio_1_1output.html">io::output</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbases_1_1element.html#afe96a343a5fea6c7894a5a78bf460155">failsafe_dump</a></td></tr>
<tr class="memdesc:afe96a343a5fea6c7894a5a78bf460155"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation to dump in case of failure. <br/></td></tr>
<tr class="separator:afe96a343a5fea6c7894a5a78bf460155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a876491b92ecc30b15971b72a04199262"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a876491b92ecc30b15971b72a04199262"></a>
std::shared_ptr&lt; <a class="el" href="classio_1_1output.html">io::output</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbases_1_1element.html#a876491b92ecc30b15971b72a04199262">normal_stream</a></td></tr>
<tr class="memdesc:a876491b92ecc30b15971b72a04199262"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation to output in normal space. <br/></td></tr>
<tr class="separator:a876491b92ecc30b15971b72a04199262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f154ce2a7a6cb41810a412d56dc0d05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f154ce2a7a6cb41810a412d56dc0d05"></a>
std::shared_ptr&lt; <a class="el" href="classio_1_1output.html">io::output</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbases_1_1element.html#a9f154ce2a7a6cb41810a412d56dc0d05">transform_stream</a></td></tr>
<tr class="memdesc:a9f154ce2a7a6cb41810a412d56dc0d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation to output in transform space. <br/></td></tr>
<tr class="separator:a9f154ce2a7a6cb41810a412d56dc0d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bfaed78e051894cdcb980272953a8df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bfaed78e051894cdcb980272953a8df"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbases_1_1element.html#a4bfaed78e051894cdcb980272953a8df">boundary_weights</a></td></tr>
<tr class="memdesc:a4bfaed78e051894cdcb980272953a8df"><td class="mdescLeft">&#160;</td><td class="mdescRight">A double vector of boundary weights. <br/></td></tr>
<tr class="separator:a4bfaed78e051894cdcb980272953a8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a09a337604df64eed6477718d9f120f91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09a337604df64eed6477718d9f120f91"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>plan</b></td></tr>
<tr class="separator:a09a337604df64eed6477718d9f120f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is the basic class of the code. </p>
<hr/>
<p> A true run will contain multiple elements linked together at the boundaries. This code is designed to work by the collocation method. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ad6c297b8fbb3ea61a1a7048f0fbf7d89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;int&gt;::<a class="el" href="classbases_1_1element.html#ad6c297b8fbb3ea61a1a7048f0fbf7d89">iterator</a> <a class="el" href="classbases_1_1element.html#ad6c297b8fbb3ea61a1a7048f0fbf7d89">bases::element::iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An iterator for the element class. </p>
<hr/>
<p> This iterator steps through the scalar fields in the order they were added. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a06505a1d8050683b6a9a07b4b92f38f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bases::element::element </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_boundaries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceio.html#a1c55c654666eeece6a9724f453fdbd87">io::parameter_map</a> &amp;&#160;</td>
          <td class="paramname"><em>i_inputParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbases_1_1messenger.html">messenger</a> *&#160;</td>
          <td class="paramname"><em>i_messenger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_name</td><td>The string representation of the element </td></tr>
    <tr><td class="paramname">n_boundaries</td><td>The integer number of boundaries (must be a multiple of 2) </td></tr>
    <tr><td class="paramname">i_inputParams</td><td>The parameter object that contains the input parameters of the run </td></tr>
    <tr><td class="paramname">i_messenger_ptr</td><td>A pointer to a messenger object </td></tr>
    <tr><td class="paramname">i_flags</td><td>An integer set of execution flags </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad1ebcca153d00d0279df6c395ad91e83"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bases::element::add_implicit_plan </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classbases_1_1plan.html">plan</a> &gt;&#160;</td>
          <td class="paramname"><em>i_plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an implicit plan to be executed in order once at the start. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_plan</td><td>A shared pointer to the plan to add </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aac0b4f2a8cf1aa6f6831ba99fe9d32df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bases::element::add_post_plan </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classbases_1_1plan.html">plan</a> &gt;&#160;</td>
          <td class="paramname"><em>i_plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a plan to be executed in order. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_plan</td><td>A shared pointer to the plan to add </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa3ee0ec9bda610aead7a6c8a02b84e19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bases::element::add_pre_plan </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classbases_1_1plan.html">plan</a> &gt;&#160;</td>
          <td class="paramname"><em>i_plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a plan to be executed in order. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_plan</td><td>A shared pointer to the plan to add </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a798c23f47fb27d78569619cff8a03cf8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bases::element::add_solver </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classbases_1_1solver.html">solver</a> &gt;&#160;</td>
          <td class="paramname"><em>i_solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the matrix solver. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_solver</td><td>A shared_ptr to a solver object <pre class="fragment">       TODO This assumes 1 equation. It should be generalized for multiple equations.</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9e46cf2492d82e9574ebcdbd39be3391"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bases::element::add_transform </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classbases_1_1plan.html">plan</a> &gt;&#160;</td>
          <td class="paramname"><em>i_plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the transform operation. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_plan</td><td>A shared_ptr to the transform object <pre class="fragment">       TODO This assumes one scalar field. It should be generalized.</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa323f71efe1d063f3a75fb0ae52dd4e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbases_1_1element.html#ad6c297b8fbb3ea61a1a7048f0fbf7d89">iterator</a> bases::element::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the iterator for the class at the first scalar index. </p>
<hr/>
<p> This iterator has all the properties of a vector iterator. Dereferencing it returns the scalar indices in the order they were added.</p>
<dl class="section return"><dt>Returns</dt><dd>The iterator for the element at the first scalar index </dd></dl>

</div>
</div>
<a class="anchor" id="aa8a344e596bf8cee3fdeda611b98bb1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double bases::element::calculate_timestep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the new timestep duration. </p>
<hr/>
<p> This method should be overwritten in the final class. It uses the knowledge of the user to beat numerical instabilities.</p>
<dl class="section return"><dt>Returns</dt><dd>The double recommended timestep for the next timestep </dd></dl>

<p>Implemented in <a class="el" href="classone__d_1_1chebyshev_1_1cuda__element.html#a528350be3f4edf1470ca31576b3f7ea2">one_d::chebyshev::cuda_element</a>, and <a class="el" href="classone__d_1_1chebyshev_1_1advection__diffusion__element.html#a935392ea158d867bcc28733c72e3c9ae">one_d::chebyshev::advection_diffusion_element</a>.</p>

</div>
</div>
<a class="anchor" id="a56ecd5c3a4ca85b1a818c9ff0d0d0213"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbases_1_1element.html#ad6c297b8fbb3ea61a1a7048f0fbf7d89">iterator</a> bases::element::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the iterator for the class at the last scalar index. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>The iterator for the element at the last scalar index </dd></dl>

</div>
</div>
<a class="anchor" id="a86a15277a82abbc28ba75f67817e170a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bases::element::execute_boundaries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute the boundary conditions. </p>
<hr/>
<p> In general, this should be overwritten in subclasses.</p>
<p>TODO I'm not entirely enthused about this method. </p>

<p>Implemented in <a class="el" href="classone__d_1_1element.html#a0d441c27c008871174b291b191f67323">one_d::element</a>.</p>

</div>
</div>
<a class="anchor" id="ac2a829e5dc54ab249d8b567f608e7f69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bases::element::explicit_reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset every scalar index &lt; 0 and converts to spectral space. </p>
<hr/>
<p> At the beginning of each timestep, all scalars with index &lt; 0 should be reset (e.g. the right hand sides of equations have index &lt; 0). This must be overwritten in a subclass, which should likely call the base method. The base method converts from normal space to spectral space if necessary. </p>

<p>Reimplemented in <a class="el" href="classone__d_1_1element.html#a14ad15e9b835116cd90947c9305725d9">one_d::element</a>.</p>

</div>
</div>
<a class="anchor" id="a8924e3a51b3c02433c082ebbb94c47d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bases::element::failsafe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output all information to a dump file in the current directory. </p>
<hr/>
<p> This failsafe method is designed to create a snapshot immediately before the simulation crashed. </p>

</div>
</div>
<a class="anchor" id="a0311b32b397accaba0b9066c6c402274"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bases::element::implicit_reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset any matrices if necessary. </p>
<hr/>
<p> This method should be overwritten if the element solves with an implicit part. It should only be called if the timestep duration has changed, for the most part. </p>

<p>Reimplemented in <a class="el" href="classone__d_1_1chebyshev_1_1cuda__element.html#ac304ac234f63b576d3acab5c31c9a31f">one_d::chebyshev::cuda_element</a>, and <a class="el" href="classone__d_1_1chebyshev_1_1advection__diffusion__element.html#a9f38631c75ee45cda5ce33ee51bddfc8">one_d::chebyshev::advection_diffusion_element</a>.</p>

</div>
</div>
<a class="anchor" id="a8c0350a45f7aff09ba8ebbfb2a789027"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bases::element::initialize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>initial_conditions</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the scalar name. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The integer name index to be initialized </td></tr>
    <tr><td class="paramname">initial_conditions</td><td>The double array of initial conditions </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classone__d_1_1chebyshev_1_1element.html#a9af801e1cdc7ccfb79500ba7efad4359">one_d::chebyshev::element</a>, and <a class="el" href="classone__d_1_1element.html#ad6885917730b12fa85d698850184cd4f">one_d::element</a>.</p>

</div>
</div>
<a class="anchor" id="aec8a0151fcc9259e3313558a928fdf62"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double&amp; bases::element::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the double reference to the given index of the named scalar. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The integer name from the index enumeration </td></tr>
    <tr><td class="paramname">index</td><td>The integer index of interest <pre class="fragment">       For simplicity, this may need to be overloaded in higher dimensions.
</pre></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A double reference to the given index of the named scalar </dd></dl>

</div>
</div>
<a class="anchor" id="a4ae6c42893603fc086c5c207e236f9d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double&amp; bases::element::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the double reference to the named scalar. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The integer name from the index enumeration <pre class="fragment">       This must be implemented in a subclass and will depend on the 
       storage system.
</pre></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A double reference to the first element of the named scalar </dd></dl>

<p>Implemented in <a class="el" href="classone__d_1_1element.html#a1d3fa9f4c9f6aacc378f1a71f2729825">one_d::element</a>.</p>

</div>
</div>
<a class="anchor" id="a4a8ef296f0853fc3e1941b696eee7dc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bases::element::run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The main function call of the class. </p>
<hr/>
<p> This method tells the element to begin the main run of the simulation. It runs through all the specified plans in the appropriate order, and updates the values as necessary. Output, if desired, is specified by the output streams. </p>

</div>
</div>
<a class="anchor" id="a4db7290cae3a85a32e28a6f73457c08c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bases::element::set_grid </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classbases_1_1collocation__grid.html">collocation_grid</a> &gt;&#160;</td>
          <td class="paramname"><em>i_grid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the collocation grid. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_grid</td><td>A shared_ptr to a <a class="el" href="classbases_1_1collocation__grid.html" title="A class containing a collocation grid.">collocation_grid</a> object <pre class="fragment">       TODO This assumes 1D n^3. Either the grid should be moved to a subclass or made more general</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aebdb8f7c290f78cc9e9abb019e96eeaf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bases::element::transform_inverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform from spectral space to physical space. </p>
<hr/>
<p> In some cases, like the cosine transform, this can work in reverse.</p>
<p>TODO Multiple transforms and batch transforms should be possible TODO Need implementation if reverse transform is not forward transform </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/justinbrown/Dropbox/spectral_element/src/bases/<a class="el" href="element_8hpp_source.html">element.hpp</a></li>
<li>/Users/justinbrown/Dropbox/spectral_element/src/bases/<a class="el" href="element_8cpp.html">element.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Aug 19 2013 23:34:20 for Spectral Element Code by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
